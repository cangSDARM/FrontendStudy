<!-- TOC -->

- [lookup 表](#lookup-表)
- [图片懒加载](#图片懒加载)
- [脚本延迟加载](#脚本延迟加载)
  - [defer/async](#deferasync)
  - [动态脚本插入(可以参考 require.js)](#动态脚本插入可以参考-requirejs)
- [函数节流(throttle)](#函数节流throttle)
- [函数防抖(debounce)](#函数防抖debounce)
- [分时函数](#分时函数)
- [惰性判断](#惰性判断)
- [懒加载的属性](#懒加载的属性)
- [精确的定时器](#精确的定时器)
- [鼠标拖放](#鼠标拖放)
- [媒体查询](#媒体查询)
- [选择监听](#选择监听)
- [颜色进制互相转换](#颜色进制互相转换)
- [判断函数是否可以 new/是否是 constructor](#判断函数是否可以-new是否是-constructor)
- [Clipboard](#clipboard)

<!-- /TOC -->

### lookup 表

一种 switch-case 的替代方案

```js
function validate(x){
    const lookup = {
        x: () => {},
        y: () => {}
    },

    var doz = function (){
        // body...
    };
    lookup[x] ? lookup[x]() : doz();
}
```

### 图片懒加载

img 的 src 设置时才会向服务器发起请求加载图片，<br/>
因此懒加载目的就在于让 img 在可视区域时才获得 src 属性

```jsx
//首先在DOM节点保存将要加载的属性：
<img data-img="img/base64:pngxxxx" />   //data-*属性来存储数据
//之后在可视区域时 参考: (https://juejin.im/post/5be03f4fe51d45053a454e69)，通常使用 getBoundingClientRect 方法
<img src="img/base64:pngxxxx" />    //将data-*换成src属性
```

### 脚本延迟加载

#### defer/async

```html
<script defer src="https://github.com">
  //defer 异步加载，等元素解析完成之后，DOMContentLoaded事件触发之前执行
</script>
<script async src="https://github.com">
  //async 异步加载，加载完后即执行
</script>
```

#### 动态脚本插入(可以参考 require.js)

```html
<script>
  function(callback){
      var script = document.createElement('script');
      script.src = "https://github.com";
      script.async = true;
      var entry = document.getElementByTagName('script')[0];
      entry.parentNode.instertBefore(script, entry);

      script.onload = script.onreadystatechange = function(){
          var readyState = script.readyState; //onreadystatechange和readyState是IE特有的属性
          if (!readyState || /complete|loaded/.test(script.readyState)){
              callback();
              script.onload = null;
              script.onreadystatechange = null; //IE需要解除事件绑定防止内存泄漏
          }
      }
  }
</script>
```

### 函数节流(throttle)

触发频率过高 -> 不允许方法在每 wait 毫秒间执行超过一次 -> 节流<br/>
使用闭包实现，是闭包的一个范例

```js
//@parmas: fn [Function] need be throttled function
//@parmas: invterval [number] delaied time
const throttle = (fn, interval) => {
  let _self = fn, //保存需要被延迟执行的函数的引用
    timer = null, //定时器
    firstTime = true; //是否是第一次调用

  return function (...args) {
    const _me = this;
    if (firstTime) {
      //如果是第一次调用则不需要执行
      _self.apply(_me, args);
      return (firstTime = false);
    }

    if (timer) {
      //如果定时器还在，说明上一次执行未完成
      return false;
    }

    timer = setTimeout(function () {
      //延迟执行
      clearTimeout(timer);
      timer = null;
      _self.apply(_me, args);
    }, interval || 5000);
  };
};

window.onresize = throttle(function () {
  console.log(1);
}, 500);
```

### 函数防抖(debounce)

触发频率过高 -> 最后一次调用才执行 -> 防抖<br/>

```js
let reduceEvent;
function debounce(cb, delay) {
  if (!reduceEvent) {
    reduceEvent = setTimeout(() => {
      cb();
      console.log("执行啦！！");
      reduceEvent = null;
    }, delay);
  }
}

window.oninput = debounce(() => console.log(1), 2000);
```

### 分时函数

数据过大引起不适 -> 分为 Chunk

```js
//@params: data [Object] the data that need
//@params: fn [Function] the logical function
//@params: count [number] the data count
const timeChunk = (data, fn, count) => {
  let obj, t;
  const len = data.length;
  const start = () => {
    for (let i = 0; i < Math.min(count || 1, data.length); i++) {
      fn(data.shift()); //提取第一个数据调用
    }
  };

  return function () {
    t = setInterval(function () {
      if (data.length === 0) {
        //如果数据用完了
        return clearInterval(t);
      }
      start();
    }, 200); //chunk 间隔
  };
};
ary = []; //假设有1000个数据
timeChunk(
  ary,
  function (n) {
    const div = document.createElement("div");
    div.innerHTML = n;
    document.body.appendChild(div);
  },
  8,
)();
```

### 惰性判断

每次运行都要执行 if/else -> 惰性判断提前判断，以后调用都没有 if/else<br/>
本质上是动态绑定

```js
const addEvent = function (elem, type, handler) {
  if (window.addEventListener) {
    addEvent = function (elem, type, handler) {
      elem.addEventListener(type, handler, false);
    };
  } else if (window.attachEvent) {
    addEvent = function (elem, type, handler) {
      elem.attachEvent("on" + type, handler);
    };
  }

  addEvent(elem, type, handler);
};
```

### 懒加载的属性

某个属性需要非常耗时的计算，并且需要在每个实例上访问

```js
//too simple version: 有可能这个data不会被使用，但是还是被计算了
class MyClass {
  constructor() {
    this.data = someExpensiveComputation();
  }
}
//class first version
class MyClass {
  constructor() {
    Object.defineProperty(this, "data", {
      get() {
        const actualData = someExpensiveComputation();
        //类似于惰性判断，覆盖掉现有的get/set。这样只会在第一次调用时缓慢，之后都会快上许多
        Object.defineProperty(this, "data", {
          value: actualData,
          writable: false,
          configurable: false,
        });
        return actualData;
      },
      configurable: true,
      enumerable: true,
    });
  }
}
//object version
const object = {
  //简单的object也可以通过这种形式来做到懒加载的属性
  get data() {
    const actualData = someExpensiveComputation();
    Object.defineProperty(this, "data", {
      value: actualData,
      writable: false,
      configurable: false,
      enumerable: false,
    });
    return actualData;
  },
};
```

### 精确的定时器

setInterval 由于 JS 的事件管理，可能会造成微小的偏差 -> 使用安全的定时器<br/>
由于链式调用了 setTimeout，在前一个执行完之前不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。并且保证下次调用之前执行稳定的间隔<br/>
这也可以实现函数节流

```js
//未启用严格模式下，可以调用arguments.callee来引用函数自身做递归
//https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments/callee
setTimeout(function () {
  //Do something at there
  setTimeout(arguments.callee, interval);
}, interval);
//启用严格模式
setTimeout(function inner() {
  //Do something at there
  setTimeout(inner, interval);
}, interval);
```

### 鼠标拖放

[sample](https://codepen.io/PJCHENder/pen/VzBVxd?editors=0110)

### 媒体查询

```js
window.matchMedia("(min-width: 500px)").addListener(Callback);
```

### 选择监听

没有直接监听选择字的事件, 但有读取选择区间的<br/>
所以可以加一步鼠标监听来配合达到

```js
function getSelectedText() {
  if (window.getSelection) {
    return window.getSelection().toString();
  } else if (document.selection) {
    return document.selection.createRange().text;
  }
  return "";
}
$("div").mouseup(function () {
  const text = getSelectedText();
  if (text != "") {
    //do something
  }
});
```

### 颜色进制互相转换

```js
function hexToRGB(hex) {
  var hexx = hex.replace("#", "0x");
  var r = hexx >> 16;
  var g = (hexx >> 8) & 0xff;
  var b = hexx & 0xff;
  return `rgb(${r}, ${g}, ${b})`;
}
function RGBToHex(rgb) {
  var rgbArr = rgb.split(/[^\d]+/);
  var color = (rgbArr[1] << 16) | (rgbArr[2] << 8) | rgbArr[3];
  return "#" + color.toString(16);
}
// -------------------------------------------------
hexToRGB("#ffffff"); // 'rgb(255,255,255)'
RGBToHex("rgb(255,255,255)"); // '#ffffff'
```

### 判断函数是否可以 new/是否是 constructor

```js
function IsConstructor(o) {
  if (typeof o !== "function") return false;
  o = Object.assign(o.bind(), { prototype: null });
  try {
    return class extends o {}, true;
  } catch {
    return false;
  }
}
//https://github.com/ljharb/es-abstract/blob/ddd63a11aac42a3fedf756e76763fe2001a51d66/2021/IsConstructor.js
function IsConstructor2(o) {
  const mark = {};
  const args = {
    get length() {
      throw mark;
    },
  };
  try {
    Reflect.construct(o, args);
  } catch (e) {
    return e === mark;
  }
}
```

### Clipboard

> Copy
```ts
function copy(value: string): void {
  if (this.copyText(value)) return;

  const inputDOM = document.createElement("textarea");
  inputDOM.value = value;
  document.body.appendChild(inputDOM);

  inputDOM.select();
  document.execCommand("copy");

  inputDOM.style.display = "none";
  document.body.removeChild(inputDOM);
}
function copyText(text: string): boolean {
  try {
    navigator.clipboard.writeText(text);

    return true;
  } catch (e) {
    console.error("Failed to copy: ", e);

    return false;
  }
}
```

> write
> https://web.dev/async-clipboard/