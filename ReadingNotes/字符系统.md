- [Unicode 字符集](#unicode-字符集)
  - [元字符集](#元字符集)
    - [字素](#字素)
    - [区域](#区域)
    - [字素 \<-\> 元字符集](#字素---元字符集)
  - [码位](#码位)
    - [UTF-32](#utf-32)
    - [UTF-8](#utf-8)
    - [UTF-16](#utf-16)
    - [UCS-2](#ucs-2)
    - [特殊码位](#特殊码位)
- [GB2312 (字符集+编码)](#gb2312-字符集编码)
  - [字符集](#字符集)
  - [编码](#编码)
- [BIG5 (字符集 + 编码)](#big5-字符集--编码)
  - [字符集](#字符集-1)
  - [编码](#编码-1)
- [GBK (字符集 + 编码)](#gbk-字符集--编码)
  - [字符集](#字符集-2)
  - [编码](#编码-2)
- [GB18030 (字符集 + 编码)](#gb18030-字符集--编码)
  - [字符集](#字符集-3)
  - [编码](#编码-3)
- [编程语言](#编程语言)
  - [JS](#js)

## Unicode 字符集

曾经有两个团队，同时想搞统一字符集。一个是 1988 年成立的 Unicode 团队，另一个是 1989 年成立的 UCS 团队
1991 年 10 月，两个团队决定合并字符集，即 Unicode

Unicode 是一个将**元字符集**分配给唯一数字(**码位**)的表格系统

### 元字符集

Unicode 映射的是*基于区域设置的*元字符集。
以汉字做类比，则是汉字 <-> 笔画

_元字符集可能有非常类似的，但码位不同的存在！_, 这些类似的合称为**视觉变体** (如 𝕏 和 x, Ⅹ, Χ, ✘, ✗)

#### 字素

(grapheme) 是在特定书写系统的上下文中最小的可区分的书写单位 (如 e 和 é 是字素, 但元字符集是 e 和 ˊ)

对于字素来说, Unicode 是变长的。对于 Unicode 来说, 字素又称为**扩展字位簇**(extended grapheme cluster)

字素应该作为一个整体被选择、复制、编辑或删除

#### 区域

在不同区域，不同的字素可能显示不同，但映射的扩展字位簇相同。
即 Unicode 觉得是同一个字，但其实各地区认知不同，不是一个字。而字体处理时会根据区域设置映射不同的显示

但做为(字素的)元数据，区域设置没有被(Unicode/字体)保留

由于不同地区的字素不同，编程语言中的`toLocalString`/`toUpperCase`/`toLowerCase`在相同的输入上也会表现不同。
会根据不同的区域设置映射到不同的码位

#### 字素 <-> 元字符集

对于如何处理字素和元字符集的映射, Unicode 标准为 UAX#29(Unicode Segmentation Rule)

- C/C++/Java: 使用 ICU。它是一个来自 Unicode 自身的库，它对文本分割的所有规则进行编码
- C#: 使用 TextElementEnumerator
- node: 使用 full-icu
- Swift: 标准库就行。Swift 默认就做得很好
- UPD：Erlang/Elixir 似乎也做得很好
- 对于其他语言，可能有一个 ICU 的库或绑定
- 自己动手。Unicode 发布了机器可读的规则和表格，上面的所有库都是基于它们的

从元字符集 -> 字素有四种形式：

1. NFD，假设字素都可分解为元字符，如果不行再 1:1 映射
2. NFC，假设可以 1:1 映射，如果不行在查找可能的元字符组合
3. NFKD，类似于 NFD，但使用默认的视觉变体替换 (如 Ⅹ, Χ 统一替换为 x)
4. NFKC，类似于 NFC，但使用默认的视觉变体替换 (如 Ⅹ, Χ 统一替换为 x)

NFD 和 NFC 被称为「规范归一化」。NFKD 和 NFKC 是「兼容归一化」

### 码位

最大码位是 0x10FFFF。大约有 110 万个码位的空间, 即**代码空间**。

代码空间分为 17 组编排，每组称为**平面**(Plane)。而每平面拥有 65536(即 2^16) 个码位，共 1,114,112 个

|         平面          |     始末字符值      |                          名称含义                           |
| :-------------------: | :-----------------: | :---------------------------------------------------------: |
| 0 号平面<sup>\*</sup> |   U+0000 - U+FFFF   |       基本多文种平面 (Basic Multilingual Plane, BMP)        |
|       1 号平面        |  U+10000 - U+1FFFF  |   多文种补充平面 (Supplementary Multilingual Plane, SMP)    |
|       2 号平面        |  U+20000 - U+2FFFF  |   表意文字补充平面( Supplementary Ideographic Plane, SIP)   |
|       3 号平面        |  U+30000 - U+3FFFF  |     表意文字第三平面 (Tertiary Ideographic Plane, TIP)      |
| 4 号平面 至 13 号平面 |  U+40000 - U+DFFFF  |                      (尚未定义及使用)                       |
|       14 号平面       |  U+E0000 - U+EFFFF  | 特别用途补充平面 (Supplementary Special-purpose Plane, SSP) |
|       15 号平面       |  U+F0000 - U+FFFFF  |         私有空间（A 区）(Private Use Area-A, PUA-A)         |
|       16 号平面       | U+100000 - U+10FFFF |        私有空间（B 区）( Private Use Area-B, PUA-B)         |

- 目前已定义了大约 17 万个码位, 占 15%, 私有空间 11%
- 私有空间：保留给字体开发使用。特定字体可以将私有的字形放在该空间(例如常见的 icon-font)
- 0 号平面也称为**基本平面**(最常使用), 其他平面称为**辅助平面**
- 0 号平面内也有段特殊区域, **代理区**(Surrogate)：`0xD800 - 0xDFFF`，共 2048 个码位。目的是用两个 UTF 字符表示 BMP 以外的字符
- 平面数（17）是由 UTF-16 中代理对可以表达的内容决定的(因为标准和 UTF-16 的编码规则是同时同一批人制定的)

码位写法：`U+1F4A9`

#### UTF-32

将每个码点固定使用四字节

#### UTF-8

变长编码。码位可能被编码为一到四个字节

|      码位       | 第 1 字节 | 第 2 字节 | 第 3 字节 | 第 4 字节 |
| :-------------: | :-------: | :-------: | :-------: | --------- |
|  U+0000..007F   | 0xxxxxxx  |  不存在   |  不存在   | 不存在    |
|  U+0080..07FF   | 110xxxxx  | 10xxxxxx  |  不存在   | 不存在    |
|  U+0800..FFFF   | 1110xxxx  | 10xxxxxx  | 10xxxxxx  | 不存在    |
| U+10000..10FFFF | 11110xxx  | 10xxxxxx  | 10xxxxxx  | 10xxxxxx  |

- 与 ASCII 兼容：码位 `U+0000..007F`, 即 ASCII。在该范围内与 ASCII 码 1:1 映射
- 自带错误检测：由于第 1 字节的前缀总是与第 2-4 个字节不同, 因此可以通过前后移动 4 字节的方式*判断序列的正确性*以及*检测序列的开始和结尾*

Unicode 转 UTF-8 编码：

1. 查找对应的码位区间确定字节长度
2. 将 码位 写成 二进制表示
3. 将该二进制顺次代替表中的 x，即为该字符的 UTF-8 编码

如“汉”：`U+6C49`(Unicode 码) -> 第三码位 -> `0110 1100 0100 1001`(二进制) -> `11100110 10110001 10001001`(顺次替换) -> `0xE6B189`(UTF-8 编码表示)

`utf8mb3` 和 `utf8mb4`：

- `utf8mb3` 是 Mysql 的魔改版本。mb3 限制死了最多只有 3 字节，导致无法存储辅助平面的字符
- `utf8mb4` 是正常的 utf-8 (^5.5.3 版本)
- Mysql 的 uft8 是 `utf8mb3` 的 alias

#### UTF-16

变长编码。基本平面(U+0000 到 U+FFFF)的占 2 字节, 其他占 4 字节(U+010000 到 U+10FFFF)

如果是辅助平面的字符, 则将其映射进代理区：高位(U+D800 到 U+DBFF) + 低位(U+DC00 到 U+DFFF)

转换公式：

```
# unicode -> bytes
c = code point

H = Math.floor((c-0x10000) / 0x400)+0xD800
L = (c - 0x10000) % 0x400 + 0xDC00

H L

# bytes -> unicode
C = (H - 0xD800) * 0x400 + L - 0xDC00 + 0x10000
```

如 𝌆：`U+1D306`(Unicode) -> `0xD834`(H)/`0xDF06`(L) -> `0xD834DF06`(UTF-16 表示)

#### UCS-2

1990 年 UCS 公布了第一套编码方法 UCS-2。UTF-16 编码迟至 1996 年 7 月公布，是 UCS-2 的超集

- UCS-2 没有代理对，因此 U+D800 到 U+DFFF 内的值被占用
- UCS-2 固定长度，统一编码为 2 字节(没法包含辅助平面)

#### 特殊码位

- `U+FFFD`(替换字符, �)：当应用程序和库检测到 Unicode 错误时, 通常使用该码位替换错误位
- `U+FE00 - U+FE0F`(变体选择器)：用于在从字素 -> 元字符集时选择特定的变体
  - 缩写为 VS1 - VS16(Variation Selectors)
  - VS1 用于：CJK 兼容、拉丁语、半宽和全宽表格、Manichaean、缅甸、缅甸 Extended-A、Phags-pa 和数学符号变异序列
  - VS2/VS3 用于：CJK 兼容
  - VS4 - VS14：保留未使用
  - VS15 用于：将文本样式变为表情符号
  - VS16 用于：将表情符号变为其他表情符号

## GB2312 (字符集+编码)

定义了字符集 + 对应编码格式，合成 GB2312

### 字符集

- 全部 ASCII 码内容
- 拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的 682 个字母
- 6763 个汉字，其中一级汉字 3755 个，二级汉字 3008 个
- 部分常用标点符号、数字

分成 94 个区，每区有 16 \* 6,96 个位，分别对应第 1 字节和第 2 字节，这种表示方式也称为区位码

- 01-09 为特殊符号 + ASCII 码
- 10-15 为用户自定义符号区（未编码）
- 16-55 为一级汉字，按拼音排序，共 3755 个
- 56-87 为二级汉字，按部首/笔画排序，共 3008 个
- 88-94 为用户自定义汉字区（未编码）

### 编码

定长编码。每个字符都固定为 2 字节

GB2312 内也加了原有的 ASCII 码，导致了**全角字符**(2 字节 GB2312 编码的 ASCII)和**半角字符**(1 字节的 ASCII 码)

- 小于 0x7F 的字符的意义与 ASCII 相同，但两个大于 0x7F 的字符连在一起时，就表示一个汉字
- 高位从 0xA1 - 0xF7，低位从 0xA1 - 0xFE

## BIG5 (字符集 + 编码)

台湾地区繁体中文标准字符集

### 字符集

- ASCII 码内容
- 标点符号、希腊字母及特殊符号
- 13053 个中文汉字

分为七个区：

- 0x8140-0xA0FE：为用户自定义汉字区（未编码）
- 0xA140-0xA3BF：为标点符号、希腊字母及特殊符号，包括在 0xA259-0xA261，安放了九个计量用汉字：兙兛兞兝兡兣嗧瓩糎
- 0xA3C0-0xA3FE：保留。没有任何作用
- 0xA440-0xC67E：为常用汉字，先按笔划再按部首排序
- 0xC6A1-0xC8FE：为用户自定义汉字区（未编码）
- 0xC940-0xF9D5：为次常用汉字，亦是先按笔划再按部首排序
- 0xF9D6-0xFEFE：为用户自定义汉字区（未编码）

### 编码

Big5 与 GB2312 没有关系，两者不兼容

定长编码。每个字符都固定为 2 字节

- 范围为 0x8140-0xFEFE 之间
- 如果高位小于 0x7E 则是 ASCII 码，低位填零忽略
- 高位从 0x81-0xFE，低位 0x40-0x7E 和 0xA1-0xFE

## GBK (字符集 + 编码)

定义了字符集 + 对应编码格式，合成 GBK

### 字符集

GBK 共收录 21886 个汉字和图形字符

- GB2312 中的全部汉字（ 6763 个）、非汉字符号
- Big5 中的全部汉字 (不兼容，但是包含 Big5汉字)
- 与 ISO 10646 相应的国家标准 GB 13000 中的其他 CJK（refer: 中日韩） 汉字
- 其他汉字、部首、符号，共计 984 个

分为三个区：

- 汉字区
  - GBK/2：0XBOA1-0xF7FE, 收录 GB2312 汉字 6763 个，按原序排列
  - GBK/3：0X8140-0xAOFE，收录 CJK 汉字 6080 个
  - GBK/4：0XAA40-0xFEAO，收录 CJK 汉字和增补的汉字 8160 个
- 图形符号区
  - GBK/1：0XA1A1-0xA9FE，除 GB2312 的符号外，还增补了其它符号
  - GBK/5：0XA840-0xA9AO，扩除非汉字区
- 用户自定义区
  - GBK 区域中的空白区，用户可以自己定义字符

### 编码

定长编码。每个字符都固定为 2 字节

- 范围为 0x8140-0xFEFE 之间(前后扩展了 GB2312，因此兼容)
- 如果高位小于 0x7E 则是 ASCII 码，低位填零忽略
- 高位从 0x81-0xFE，低位 0x40 - 0xFE 之间，即不再规定低位必须大于 0x7F

## GB18030 (字符集 + 编码)

### 字符集

- GBK 共收录的 21886 个汉字和字符
- 中国国内少数民族的文字
- 繁体汉字以及日韩汉字

### 编码

变长字节编码，每个字符可以由 1 个、2 个或 4 个字节组成

与 GB2312 和 GBK 兼容

|     编码长度      | 第 1 字节 |        第 2 字节        |  第 3 字节  | 第 4 字节   |
| :---------------: | :-------: | :---------------------: | :---------: | ----------- |
| 单字节 (ASCII 码) |  0-0x7F   |         不存在          |   不存在    | 不存在      |
| 双字节(兼容 GBK)  | 0x81-0xFE | 0x40-0xFE (不包括 0x7F) |   不存在    | 不存在      |
|      四字节       | 0x81-0xFE |        0x30-0x39        | 0x81 - 0xFE | 0x30 - 0x39 |

GB18030 编码 -> 字符：

- 如果遇到的字节的最高位是 0，那么该字符长度一字节
- 如果遇到的字节的最高位是 1，那么该字符可能两字节，也可能四字节：
  - 如果第 2 个字节的高位有两个连续的 0，那么该字符四字节长
  - 如果第 2 个字节的高位没有连续的 0，那么该字符两字节长

## 编程语言

### JS

Js 在 es6 以前使用的是 UCS-2 编码，在 es6 后使用 UTF-16 编码

JSON 标准是用 utf-8 编码，但 js 里 `JSON.stringify()` 返回是的满足 utf-8 要求的 utf-16 字符串

非正确使用 unicode：

```js
"𝌆".length; // 2
"𝌆".charAt(0); // "�"
"𝌆".charCodeAt(0); // 55348(0xD834)
"𝌆" === "\uD834\uDF06"; // true

"\172" === "z"; // true, Octal, deprecated

String.fromCharCode(55348); // \uD834

String.prototype.replace();
String.prototype.substring();
String.prototype.slice();
//...

for (let i = 0; i < text.length; i++) {
  console.log(text[i]);
}
// " "
// " "
```

正确使用：

```js
/^.$/u.test("的"); //正确匹配Unicode字符
/\p{Emoji_Presentation}/gu.test("🧡"); // 匹配Unicode的分类表

"的".codePointAt(0); // 返回字符串对应位置的Unicode编号, 能正确处理四字节或两字节
String.fromCodePoint(0x1d306, 0x61, 0x1d307); // 返回Unicode编号对应的字符串
String.fromCodePoint(3.14); // RangeError

"z" === "z"; // true, regex escape
"\x7A" === "z"; // true, Hex
"\u007A" === "z"; // true, UTF-16
"\u{7A}" === "z"; // true, unicode

let s1 = "S\u0307\u0323"; // Ṩ, S + 上方点符号 + 下方点符号
let s2 = "S\u0323\u0307"; // Ṩ, S + 下方点符号 + 上方点符号
s1 === s2; // 看着一样其实是 false
s1.normalize() === s2.normalize(); // true (“Unicode 规范化”算法)

for (let i of text) {
  console.log(i);
} // "𠮷"

// 遇到代理区内的单个码点，或者不存在的配对形式，它会返回转义字符串
JSON.stringify("\uDF06\uD834"); // "\\udf06\\ud834"
```
